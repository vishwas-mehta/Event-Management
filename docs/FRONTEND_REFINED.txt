================================================================================
          REACT FRONTEND - INTERVIEW DEEP DIVE GUIDE
          Register, Login & Browse Events - Complete Understanding
================================================================================

This guide will teach you React concepts through actual code from EventHub.
After reading this, you'll be able to write React code yourself confidently.

================================================================================
SECTION 1: REACT FUNDAMENTALS - WHAT YOU MUST KNOW
================================================================================

1.1 WHAT IS REACT?
------------------
React is a JavaScript library for building user interfaces.
- Component-based: Build small pieces (components) and combine them
- Declarative: You describe WHAT you want, React handles HOW
- Virtual DOM: React efficiently updates only what changes

1.2 WHAT IS JSX?
-----------------
JSX = JavaScript XML. It lets you write HTML-like code inside JavaScript.

Regular JavaScript:
    const element = React.createElement('h1', null, 'Hello');

JSX (cleaner):
    const element = <h1>Hello</h1>;

JSX Rules:
    1. Must return ONE parent element (wrap in <div> or <> fragment)
    2. Use className instead of class (class is reserved in JS)
    3. All tags must be closed: <img /> not <img>
    4. JavaScript expressions go in curly braces: {variable}

Example from our code:
    return (
        <div>                          // HTML-like syntax
            <h1>{user.name}</h1>       // {curly braces} for JS expressions
            {isLoggedIn && <p>Welcome</p>}  // Conditional rendering
        </div>
    );


1.3 WHAT IS A COMPONENT?
-------------------------
A component is a reusable piece of UI. Like LEGO blocks.

Two types:
    1. Function Component (modern, we use this):
        const Button = () => {
            return <button>Click me</button>;
        };
    
    2. Class Component (old, rarely used now):
        class Button extends React.Component {
            render() { return <button>Click me</button>; }
        }

Component Rules:
    1. Name must start with CAPITAL letter (Button, not button)
    2. Must return JSX (or null)
    3. Can receive "props" (properties) from parent
    4. Can have internal "state"


1.4 WHAT ARE PROPS?
--------------------
Props = Properties passed from parent to child component.
They are READ-ONLY (child cannot modify them).

Parent component:
    <UserCard name="John" age={25} />

Child component:
    const UserCard = (props) => {
        return <div>{props.name} is {props.age} years old</div>;
    };

Destructuring props (cleaner):
    const UserCard = ({ name, age }) => {
        return <div>{name} is {age} years old</div>;
    };


1.5 WHAT IS STATE? (useState Hook)
-----------------------------------
State = Data that can CHANGE and when it changes, component RE-RENDERS.

Syntax:
    const [value, setValue] = useState(initialValue);
    //     ↑        ↑                    ↑
    //  current  function to         starting
    //  value    update it           value

Example:
    const [count, setCount] = useState(0);
    
    // To update:
    setCount(5);        // Set to 5
    setCount(count + 1); // Increment by 1
    setCount(prev => prev + 1); // Safer way using previous value

IMPORTANT: Never do this:
    count = 5;  // WRONG! Won't trigger re-render

Always use the setter function:
    setCount(5);  // CORRECT!


1.6 WHAT ARE HOOKS?
--------------------
Hooks are special functions that let you "hook into" React features.
All hooks start with "use".

Common hooks:
    useState    - Manage state
    useEffect   - Side effects (API calls, subscriptions)
    useContext  - Access context values
    useNavigate - Navigation (from react-router)
    useParams   - Get URL parameters

Rules of Hooks:
    1. Only call at TOP LEVEL of component (not inside if/loops)
    2. Only call in React function components or custom hooks


================================================================================
SECTION 2: TYPESCRIPT BASICS FOR REACT
================================================================================

2.1 WHY TYPESCRIPT?
--------------------
TypeScript adds types to JavaScript. Catches errors before runtime.

Example:
    // JavaScript - no type checking
    let name = "John";
    name = 123;  // No error, but it's wrong!
    
    // TypeScript - type checking
    let name: string = "John";
    name = 123;  // ERROR! Type 'number' is not assignable to type 'string'


2.2 BASIC TYPES
----------------
    let name: string = "John";
    let age: number = 25;
    let isActive: boolean = true;
    let items: string[] = ["a", "b", "c"];  // Array of strings
    let user: { name: string; age: number } = { name: "John", age: 25 };


2.3 INTERFACES
---------------
Define the shape of an object:

    interface User {
        id: string;
        email: string;
        firstName: string;
        lastName: string;
        role: 'admin' | 'organizer' | 'attendee';  // Union type (one of these)
    }
    
    const user: User = {
        id: "123",
        email: "john@example.com",
        firstName: "John",
        lastName: "Doe",
        role: "attendee"
    };


2.4 REACT.FC (Function Component Type)
----------------------------------------
    const MyComponent: React.FC = () => {
        return <div>Hello</div>;
    };
    
    // With props:
    interface Props {
        name: string;
        age?: number;  // ? means optional
    }
    
    const MyComponent: React.FC<Props> = ({ name, age }) => {
        return <div>{name} - {age}</div>;
    };


================================================================================
SECTION 3: LOGIN PAGE - LINE BY LINE EXPLANATION
================================================================================

Location: src/pages/Auth/LoginPage.tsx

Let me explain EVERY LINE:

```typescript
// ============ IMPORTS ============

import React, { useState } from 'react';
// React: The core library (required for JSX to work)
// useState: Hook to manage component state (form inputs, loading, errors)

import { useNavigate, Link } from 'react-router-dom';
// useNavigate: Hook to programmatically navigate (redirect after login)
// Link: Component to create clickable links without page reload

import { Container, Form, Button, Card, Alert } from 'react-bootstrap';
// Pre-styled components from Bootstrap library
// Container: Centers content with padding
// Form: Form wrapper and input components
// Button: Styled button
// Card: Box with shadow and padding
// Alert: Colored message box (for errors)

import { useAuth } from '../../contexts/AuthContext';
// Custom hook to access authentication context
// Returns: { user, login, logout, register, ... }

import { extractErrorMessage } from '../../utils/errorHelper';
// Utility function to get readable error message from API errors


// ============ COMPONENT DEFINITION ============

const LoginPage: React.FC = () => {
// React.FC = React Function Component type
// () => { ... } is an arrow function (modern way to define functions)

    // ============ STATE DECLARATIONS ============
    
    const [email, setEmail] = useState('');
    // Creates state variable 'email' with initial value '' (empty string)
    // setEmail is the function to update this value
    // When setEmail is called, component re-renders with new value
    
    const [password, setPassword] = useState('');
    // Same pattern for password
    
    const [error, setError] = useState('');
    // For storing error messages to display to user
    
    const [loading, setLoading] = useState(false);
    // For showing loading spinner on button while API call happens


    // ============ HOOKS ============
    
    const { login, user } = useAuth();
    // Destructuring: pulls 'login' function and 'user' object from context
    // login: async function to authenticate user
    // user: currently logged in user (or null if not logged in)
    
    const navigate = useNavigate();
    // Hook from react-router that returns a navigate function
    // Used to programmatically change the URL


    // ============ EVENT HANDLER ============
    
    const handleSubmit = async (e: React.FormEvent) => {
    // async: This function contains await (asynchronous operations)
    // e: The event object (contains info about form submission)
    // React.FormEvent: TypeScript type for form events
    
        e.preventDefault();
        // CRITICAL: Prevents form from doing default browser behavior
        // Default behavior = page reload, which would lose all React state
        // We want to handle submission ourselves via JavaScript
        
        setError('');
        // Clear any previous error message before new attempt
        
        setLoading(true);
        // Show loading state (button shows "Signing in...")

        try {
            await login({ email, password });
            // Calls login function from AuthContext
            // await: Wait for this Promise to complete before continuing
            // If successful, moves to next line
            // If fails, jumps to catch block
            
            navigate('/');
            // Navigate to home page after successful login
            // This changes URL without page reload
            
        } catch (err: any) {
            // If login fails, this block runs
            // err: The error thrown by login function
            // : any means TypeScript won't check this type (escape hatch)
            
            setError(extractErrorMessage(err, 'Failed to login. Please check your credentials.'));
            // Set error state to show message to user
            // extractErrorMessage: tries to get message from err.response.data.message
            // If that fails, uses the default message we provided
            
        } finally {
            setLoading(false);
            // finally: Runs whether try succeeded OR catch ran
            // Always turn off loading spinner when done
        }
    };


    // ============ EFFECT HOOK ============
    
    React.useEffect(() => {
        if (user) {
            navigate('/');
        }
    }, [user, navigate]);
    // useEffect: Runs code as a "side effect" after render
    // First argument: Function to run
    // Second argument: Dependency array - re-run when these change
    
    // Logic: If user is already logged in, redirect to home
    // This prevents logged-in users from seeing login page
    
    // Dependency array explained:
    // [] empty = run once on mount
    // [user] = run on mount AND whenever user changes
    // [user, navigate] = run when either changes


    // ============ JSX RETURN ============
    
    return (
        <div style={{ minHeight: '100vh', display: 'flex', alignItems: 'center', background: 'var(--gray-50)' }}>
        {/* 
            div: Container for the page
            style={{ }}: Inline CSS as JavaScript object
            minHeight: '100vh' = minimum height of 100% viewport height
            display: 'flex' = flexbox layout
            alignItems: 'center' = vertically center children
            background: 'var(--gray-50)' = CSS variable for color
        */}
        
            <Container>
            {/* Bootstrap Container: centers content with max-width */}
            
                <div style={{ maxWidth: '440px', margin: '0 auto' }}>
                {/* maxWidth: 440px = card won't be wider than 440 pixels */}
                {/* margin: '0 auto' = center horizontally */}
                
                    <div className="text-center mb-4">
                    {/* className: Bootstrap classes */}
                    {/* text-center: center text */}
                    {/* mb-4: margin-bottom 4 units (1.5rem) */}
                    
                        <h2 style={{ fontSize: '2rem', fontWeight: '800', marginBottom: '0.5rem' }}>Welcome back</h2>
                        <p className="text-muted">Sign in to your EventHub account</p>
                        {/* text-muted: gray color for secondary text */}
                    </div>

                    <Card>
                    {/* Bootstrap Card: box with shadow and padding */}
                    
                        <Card.Body className="p-4">
                        {/* Card.Body: inner padding area */}
                        {/* p-4: padding 4 units all around */}
                        
                            {error && <Alert variant="danger" className="mb-4">{error}</Alert>}
                            {/* 
                                CONDITIONAL RENDERING
                                error && <Alert>: If error is truthy, render Alert
                                If error is '' (empty string = falsy), nothing renders
                                variant="danger": red color for error
                                {error}: Display the error message text
                            */}

                            <Form onSubmit={handleSubmit}>
                            {/* 
                                Form: Bootstrap form wrapper
                                onSubmit={handleSubmit}: When form is submitted, call handleSubmit
                                Triggered by clicking button type="submit" or pressing Enter
                            */}
                            
                                <Form.Group className="mb-3">
                                {/* Form.Group: Groups label and input together */}
                                
                                    <Form.Label>Email address</Form.Label>
                                    {/* Label for the input */}
                                    
                                    <Form.Control
                                        type="email"
                                        placeholder="you@example.com"
                                        value={email}
                                        onChange={(e) => setEmail(e.target.value)}
                                        required
                                        autoFocus
                                    />
                                    {/* 
                                        Form.Control: Bootstrap input element
                                        type="email": HTML5 email validation
                                        placeholder: Gray hint text when empty
                                        value={email}: CONTROLLED INPUT - value from state
                                        onChange: When user types, this function runs
                                            e = event object
                                            e.target = the input element
                                            e.target.value = current text in input
                                            setEmail(e.target.value) = update state with new text
                                        required: HTML5 validation - can't be empty
                                        autoFocus: Cursor starts here when page loads
                                    */}
                                </Form.Group>

                                <Form.Group className="mb-4">
                                    <Form.Label>Password</Form.Label>
                                    <Form.Control
                                        type="password"
                                        placeholder="Enter your password"
                                        value={password}
                                        onChange={(e) => setPassword(e.target.value)}
                                        required
                                    />
                                    {/* type="password": Shows dots instead of actual text */}
                                </Form.Group>

                                <Button
                                    variant="primary"
                                    type="submit"
                                    className="w-100 mb-3"
                                    disabled={loading}
                                    size="lg"
                                >
                                    {loading ? 'Signing in...' : 'Sign in'}
                                </Button>
                                {/* 
                                    variant="primary": Blue button (Bootstrap theme)
                                    type="submit": Clicking triggers form onSubmit
                                    className="w-100": width 100% (full width)
                                    disabled={loading}: When loading=true, button is unclickable
                                    size="lg": Large button
                                    
                                    {loading ? 'Signing in...' : 'Sign in'}
                                    TERNARY OPERATOR: condition ? ifTrue : ifFalse
                                    If loading is true, show "Signing in..."
                                    If loading is false, show "Sign in"
                                */}

                                <div className="text-center">
                                    <p className="text-muted mb-0" style={{ fontSize: '0.938rem' }}>
                                        Don't have an account?{' '}
                                        {/* {' '} adds a space in JSX */}
                                        
                                        <Link to="/register" style={{ color: 'var(--primary)', textDecoration: 'none', fontWeight: '600' }}>
                                            Sign up
                                        </Link>
                                        {/* 
                                            Link: react-router component for navigation
                                            to="/register": URL to navigate to
                                            Unlike <a href>, Link doesn't reload the page
                                            It updates URL and React renders new component
                                        */}
                                    </p>
                                </div>
                            </Form>
                        </Card.Body>
                    </Card>
                </div>
            </Container>
        </div>
    );
};

export default LoginPage;
// Makes this component available to import in other files
// Default export: can import with any name
// import LoginPage from './LoginPage' ✓
// import MyLogin from './LoginPage'  ✓ (same thing)
```


================================================================================
SECTION 4: REGISTER PAGE - KEY DIFFERENCES FROM LOGIN
================================================================================

Location: src/pages/Auth/RegisterPage.tsx

```typescript
// ============ STATE - SINGLE OBJECT INSTEAD OF MULTIPLE ============

const [formData, setFormData] = useState({
    email: '',
    password: '',
    confirmPassword: '',
    firstName: '',
    lastName: '',
    phoneNumber: '',
    role: 'attendee' as 'attendee' | 'organizer',  // Type assertion
});
// Alternative to having 7 separate useState calls
// Groups related data together
// "as 'attendee' | 'organizer'" tells TypeScript the allowed values

const [error, setError] = useState('');
const [success, setSuccess] = useState('');  // NEW: For success message
const [loading, setLoading] = useState(false);


// ============ GENERIC CHANGE HANDLER ============

const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    setFormData({
        ...formData,                    // Spread: copy all existing fields
        [e.target.name]: e.target.value // Computed property: update just this field
    });
};
/*
    React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
    - ChangeEvent: Type for onChange events
    - <HTMLInputElement | HTMLSelectElement>: Can be input OR select element
    
    ...formData (spread operator):
    If formData = { email: 'a@b.com', password: '123', firstName: 'John' }
    {...formData} creates a copy: { email: 'a@b.com', password: '123', firstName: 'John' }
    
    [e.target.name]: Computed property name
    If e.target.name = "email" and e.target.value = "new@email.com"
    Then [e.target.name]: e.target.value becomes { email: 'new@email.com' }
    
    Combined:
    { ...formData, [e.target.name]: e.target.value }
    = { email: 'new@email.com', password: '123', firstName: 'John' }
*/


// ============ FORM VALIDATION ============

const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setSuccess('');
    setLoading(true);

    // Client-side validation (before API call)
    if (formData.password !== formData.confirmPassword) {
        setError('Passwords do not match');
        setLoading(false);
        return;  // Early return - stop execution here
    }

    if (formData.password.length < 6) {
        setError('Password must be at least 6 characters');
        setLoading(false);
        return;
    }

    try {
        await register({
            email: formData.email,
            password: formData.password,
            firstName: formData.firstName,
            lastName: formData.lastName,
            role: formData.role,
            phoneNumber: formData.phoneNumber || undefined,
            // || undefined: if empty string, send undefined (optional field)
        });

        if (formData.role === 'organizer') {
            // Organizers need admin approval
            setSuccess('Registration successful! Your account is pending admin approval.');
            setTimeout(() => navigate('/login'), 3000);
            // setTimeout: Wait 3 seconds, then navigate
            // Gives user time to read success message
        } else {
            navigate('/');  // Attendees go straight to home
        }
    } catch (err: any) {
        setError(extractErrorMessage(err, 'Failed to register. Please try again.'));
    } finally {
        setLoading(false);
    }
};


// ============ JSX - USING GRID LAYOUT ============

<Row>
    <Col md={6}>
        {/* First Name */}
        <Form.Group className="mb-3">
            <Form.Label>First name</Form.Label>
            <Form.Control
                type="text"
                name="firstName"          // IMPORTANT: matches formData key
                placeholder="John"
                value={formData.firstName}
                onChange={handleChange}   // Same handler for all inputs!
                required
            />
        </Form.Group>
    </Col>
    <Col md={6}>
        {/* Last Name */}
        <Form.Group className="mb-3">
            <Form.Label>Last name</Form.Label>
            <Form.Control
                type="text"
                name="lastName"
                placeholder="Doe"
                value={formData.lastName}
                onChange={handleChange}
                required
            />
        </Form.Group>
    </Col>
</Row>
/*
    Row and Col: Bootstrap grid system
    Row: Horizontal container
    Col: Column within row
    md={6}: On medium screens and up, take 6 out of 12 columns (50%)
    
    Two Col md={6} in one Row = 2 columns side by side
    On mobile: columns stack vertically automatically
*/


// ============ SELECT DROPDOWN ============

<Form.Group className="mb-4">
    <Form.Label>I want to</Form.Label>
    <Form.Select
        name="role"
        value={formData.role}
        onChange={handleChange}
        required
    >
        <option value="attendee">Attend events</option>
        <option value="organizer">Organize events</option>
    </Form.Select>
    
    {formData.role === 'organizer' && (
        <Form.Text className="text-muted d-block mt-2">
            <i className="bi bi-info-circle me-1"></i>
            Organizer accounts require admin approval
        </Form.Text>
    )}
</Form.Group>
/*
    Form.Select: Dropdown menu
    value={formData.role}: Which option is selected (controlled)
    
    Conditional rendering inside JSX:
    {formData.role === 'organizer' && (...)}
    Only shows the info text when organizer is selected
*/
```


================================================================================
SECTION 5: EVENTS BROWSE PAGE - COMPLETE BREAKDOWN
================================================================================

Location: src/pages/Events/EventsPage.tsx

```typescript
import React, { useState, useEffect } from 'react';
// useEffect: For fetching data when component loads and when filters change

import { Container, Row, Col, Form, Button, Card } from 'react-bootstrap';
// Layout and form components from Bootstrap

import { eventsApi } from '../../api/events.api';
// Our API functions for events

import type { EventType, EventFilters, CategoryType } from '../../types';
// TypeScript types (interfaces) we defined
// "type" keyword imports only the type, not runtime code

import EventCard from '../../components/Events/EventCard';
// Reusable component to display one event

import LoadingSpinner from '../../components/Common/LoadingSpinner';
import ErrorAlert from '../../components/Common/ErrorAlert';
import Pagination from '../../components/Common/Pagination';
// Common reusable components


const EventsPage: React.FC = () => {
    
    // ============ MULTIPLE STATE VARIABLES ============
    
    const [events, setEvents] = useState<EventType[]>([]);
    // Array of events, starts empty
    // <EventType[]> is TypeScript generic - tells it what type is in array
    
    const [categories, setCategories] = useState<CategoryType[]>([]);
    // Array of categories for filter dropdown
    
    const [loading, setLoading] = useState(true);
    // true initially - show spinner while first load happens
    
    const [error, setError] = useState('');
    
    const [filters, setFilters] = useState<EventFilters>({
        page: 1,
        limit: 12,
        sortBy: 'date',
        order: 'ASC',
    });
    // Object containing all filter options
    // When any filter changes, we'll refetch events
    
    const [pagination, setPagination] = useState({
        total: 0,
        page: 1,
        limit: 12,
        totalPages: 0,
    });
    // Pagination info from API response


    // ============ useEffect FOR DATA FETCHING ============
    
    useEffect(() => {
        loadCategories();
    }, []);
    // Empty dependency array [] = runs ONCE when component mounts
    // Categories don't change, so we only need to fetch once
    
    useEffect(() => {
        loadEvents();
    }, [filters]);
    // [filters] = runs when filters change
    // When user changes a filter, events are refetched
    // Also runs on first mount (initial render)


    // ============ API CALL FUNCTIONS ============
    
    const loadCategories = async () => {
        try {
            const response = await eventsApi.getCategories();
            setCategories(response.data.categories);
        } catch (err) {
            console.error('Failed to load categories:', err);
            // Non-critical error - just log, don't show to user
        }
    };

    const loadEvents = async () => {
        setLoading(true);
        setError('');
        try {
            const response = await eventsApi.getEvents(filters);
            // filters object: { page: 1, limit: 12, sortBy: 'date', category: 'music', ... }
            // API converts this to query string: ?page=1&limit=12&sortBy=date&category=music
            
            setEvents(response.data.events);
            setPagination(response.data.pagination);
        } catch (err: any) {
            setError('Failed to load events. Please try again.');
        } finally {
            setLoading(false);
        }
    };


    // ============ FILTER CHANGE HANDLERS ============
    
    const handleFilterChange = (key: keyof EventFilters, value: any) => {
        setFilters({ ...filters, [key]: value, page: 1 });
    };
    // keyof EventFilters = TypeScript: key must be a valid property name of EventFilters
    // page: 1 = reset to first page when filter changes
    
    const handlePageChange = (page: number) => {
        setFilters({ ...filters, page });
        window.scrollTo(0, 0);  // Scroll to top when page changes
    };
    // { ...filters, page } is shorthand for { ...filters, page: page }
    
    const clearFilters = () => {
        setFilters({
            page: 1,
            limit: 12,
            sortBy: 'date',
            order: 'ASC',
        });
    };
    // Reset to default filters


    // ============ CONDITIONAL RENDERING PATTERNS ============
    
    return (
        <Container className="py-4">
            <h2 className="mb-4">Browse Events</h2>

            <Row>
                {/* Sidebar with filters */}
                <Col md={3} className="mb-4">
                    <Card>
                        <Card.Body>
                            <h5 className="mb-3">Filters</h5>
                            
                            {/* Search Input */}
                            <Form.Group className="mb-3">
                                <Form.Label>Search</Form.Label>
                                <Form.Control
                                    type="text"
                                    placeholder="Search events..."
                                    value={filters.search || ''}
                                    onChange={(e) => handleFilterChange('search', e.target.value)}
                                />
                            </Form.Group>
                            {/* filters.search || '' : if undefined, use empty string */}
                            
                            {/* Category Dropdown */}
                            <Form.Group className="mb-3">
                                <Form.Label>Category</Form.Label>
                                <Form.Select
                                    value={filters.category || ''}
                                    onChange={(e) => handleFilterChange('category', e.target.value)}
                                >
                                    <option value="">All Categories</option>
                                    {categories.map((cat) => (
                                        <option key={cat.id} value={cat.slug}>
                                            {cat.name}
                                        </option>
                                    ))}
                                </Form.Select>
                            </Form.Group>
                            {/*
                                categories.map(): Transform array into JSX elements
                                key={cat.id}: Required! React needs unique key to track list items
                                Helps React know which items changed/added/removed
                            */}
                            
                            {/* Checkbox */}
                            <Form.Group className="mb-3">
                                <Form.Check
                                    type="checkbox"
                                    label="Free events only"
                                    checked={filters.isFree || false}
                                    onChange={(e) => handleFilterChange('isFree', e.target.checked)}
                                />
                            </Form.Group>
                            {/* 
                                For checkboxes: use e.target.checked not e.target.value 
                                checked prop controls whether box is checked
                            */}
                            
                            <Button variant="outline-secondary" size="sm" className="w-100" onClick={clearFilters}>
                                Clear Filters
                            </Button>
                        </Card.Body>
                    </Card>
                </Col>

                {/* Events Grid */}
                <Col md={9}>
                    {/* Pattern 1: Show error if exists */}
                    {error && <ErrorAlert message={error} onClose={() => setError('')} />}

                    {/* Pattern 2: Show loading spinner */}
                    {loading ? (
                        <LoadingSpinner fullScreen={false} />
                    ) : events.length === 0 ? (
                        /* Pattern 3: No results */
                        <Card>
                            <Card.Body className="text-center py-5">
                                <p className="text-muted">No events found matching your criteria.</p>
                                <Button variant="primary" onClick={clearFilters}>
                                    Clear Filters
                                </Button>
                            </Card.Body>
                        </Card>
                    ) : (
                        /* Pattern 4: Show results */
                        <>
                            <Row xs={1} md={2} lg={3} className="g-4">
                                {events.map((event) => (
                                    <Col key={event.id}>
                                        <EventCard event={event} />
                                    </Col>
                                ))}
                            </Row>
                            {/*
                                xs={1} md={2} lg={3}
                                Responsive grid:
                                - Extra small screens: 1 column
                                - Medium screens: 2 columns
                                - Large screens: 3 columns
                                
                                g-4: gap between items (gutter)
                            */}

                            <Pagination
                                currentPage={pagination.page}
                                totalPages={pagination.totalPages}
                                onPageChange={handlePageChange}
                            />
                        </>
                    )}
                    {/*
                        Nested ternary: condition1 ? result1 : condition2 ? result2 : result3
                        loading ? ShowSpinner : noResults ? ShowEmpty : ShowEvents
                        
                        <> </> is a Fragment - groups elements without adding extra DOM node
                        Same as <React.Fragment></React.Fragment>
                    */}
                </Col>
            </Row>
        </Container>
    );
};

export default EventsPage;
```


================================================================================
SECTION 6: API LAYER - HOW FRONTEND TALKS TO BACKEND
================================================================================

6.1 AXIOS CONFIGURATION (src/api/axios.ts)
-------------------------------------------

```typescript
import axios from 'axios';
// axios: Library for making HTTP requests (better than built-in fetch)

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:5000/api';
// import.meta.env.VITE_API_URL: Reads from .env file (Vite way)
// || 'http://...': Fallback if env variable not set

const api = axios.create({
    baseURL: API_URL,
    headers: {
        'Content-Type': 'application/json',
    },
});
// Creates configured axios instance
// All requests will:
//   - Start with baseURL (e.g., api.get('/events') → GET http://localhost:5000/api/events)
//   - Include Content-Type header


// ============ REQUEST INTERCEPTOR ============

api.interceptors.request.use(
    (config) => {
        const token = localStorage.getItem('token');
        if (token) {
            config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
    },
    (error) => {
        return Promise.reject(error);
    }
);
/*
    Interceptor: Runs before EVERY request is sent
    
    What this does:
    1. Get JWT token from localStorage
    2. If token exists, add it to request headers
    3. Authorization: Bearer eyJhbGciOi... (standard format)
    
    This means you don't have to manually add token to every API call!
*/


// ============ RESPONSE INTERCEPTOR ============

api.interceptors.response.use(
    (response) => response,  // Success: just return response
    (error) => {
        const isAuthEndpoint = error.config?.url?.includes('/auth/');
        const hasStoredToken = localStorage.getItem('token');

        if (error.response?.status === 401 && hasStoredToken && !isAuthEndpoint) {
            localStorage.removeItem('token');
            localStorage.removeItem('user');
            window.location.href = '/login';
        }
        return Promise.reject(error);
    }
);
/*
    Interceptor: Runs for EVERY response
    
    Handles 401 (Unauthorized) errors:
    - If user was logged in (has token) but gets 401
    - AND it's not on login/register page (auth endpoints)
    - Then: token is invalid/expired
    - Clear token and redirect to login
    
    This provides automatic logout when token expires!
*/

export default api;
```


6.2 AUTH API (src/api/auth.api.ts)
-----------------------------------

```typescript
import api from './axios';
// Our configured axios instance

import type {
    ApiResponse,
    AuthResponse,
    LoginCredentials,
    RegisterData,
    User
} from '../types';
// TypeScript types for type safety


export const authApi = {
    
    // ============ REGISTER ============
    register: async (data: RegisterData): Promise<ApiResponse<AuthResponse>> => {
        const response = await api.post('/auth/register', data);
        return response.data;
    },
    /*
        async function that:
        - Takes RegisterData object as parameter
        - Returns Promise<ApiResponse<AuthResponse>> (typed response)
        
        api.post('/auth/register', data):
        - POST request to /auth/register endpoint
        - data is sent as JSON body
        
        response.data:
        - axios puts the response body in .data property
        - We return just the data, not the whole axios response
    */
    
    // ============ LOGIN ============
    login: async (credentials: LoginCredentials): Promise<ApiResponse<AuthResponse>> => {
        const response = await api.post('/auth/login', credentials);
        return response.data;
    },
    /*
        credentials: { email: 'user@email.com', password: 'secret123' }
        
        Backend returns:
        {
            success: true,
            message: "Login successful",
            data: {
                user: { id, email, firstName, ... },
                token: "eyJhbGci..."
            }
        }
    */
    
    // ============ GET CURRENT USER ============
    getCurrentUser: async (): Promise<ApiResponse<{ user: User }>> => {
        const response = await api.get('/auth/me');
        return response.data;
    },
    /*
        GET request (no body)
        Token is automatically added by interceptor
        Used to verify token and get user data on app load
    */
    
    // ============ UPDATE PROFILE ============
    updateProfile: async (data: Partial<User>): Promise<ApiResponse<{ user: User }>> => {
        const response = await api.put('/auth/profile', data);
        return response.data;
    },
    /*
        Partial<User>: TypeScript utility type
        Makes all properties of User optional
        User = { id: string, email: string, firstName: string, ... }
        Partial<User> = { id?: string, email?: string, firstName?: string, ... }
        
        PUT = update existing resource
    */
    
    // ============ LOGOUT ============
    logout: async (): Promise<ApiResponse<null>> => {
        const response = await api.post('/auth/logout');
        return response.data;
    },
};
```


6.3 EVENTS API (src/api/events.api.ts)
---------------------------------------

```typescript
export const eventsApi = {
    
    // ============ GET EVENTS WITH FILTERS ============
    getEvents: async (filters?: EventFilters): Promise<ApiResponse<{
        events: EventType[];
        pagination: { total: number; page: number; limit: number; totalPages: number };
    }>> => {
        const params = new URLSearchParams();
        if (filters) {
            Object.entries(filters).forEach(([key, value]) => {
                if (value !== undefined && value !== null && value !== '') {
                    params.append(key, value.toString());
                }
            });
        }
        const response = await api.get(`/events?${params.toString()}`);
        return response.data;
    },
    /*
        URLSearchParams: Built-in class for building query strings
        
        filters = { page: 1, limit: 12, category: 'music', search: '' }
        
        Object.entries(filters) = [
            ['page', 1],
            ['limit', 12],
            ['category', 'music'],
            ['search', '']
        ]
        
        After filtering out empty values and appending:
        params.toString() = 'page=1&limit=12&category=music'
        
        Full URL: GET /events?page=1&limit=12&category=music
    */
    
    // ============ GET SINGLE EVENT ============
    getEventById: async (id: string): Promise<ApiResponse<{ event: EventType }>> => {
        const response = await api.get(`/events/${id}`);
        return response.data;
    },
    /*
        Template literal: `backticks allow ${variables} inside`
        If id = "abc123", URL becomes /events/abc123
    */
    
    // ============ GET CATEGORIES ============
    getCategories: async (): Promise<ApiResponse<{ categories: CategoryType[] }>> => {
        const response = await api.get('/events/categories');
        return response.data;
    },
};
```


================================================================================
SECTION 7: CONTEXT & GLOBAL STATE (AuthContext)
================================================================================

Location: src/contexts/AuthContext.tsx

```typescript
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';


// ============ STEP 1: CREATE CONTEXT ============

const AuthContext = createContext<AuthContextType | undefined>(undefined);
/*
    createContext: Creates a "container" that can hold shared data
    <AuthContextType | undefined>: The type of data it holds
    undefined: Initial value (before provider sets real value)
*/


// ============ STEP 2: CREATE PROVIDER COMPONENT ============

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
/*
    Provider: Component that PROVIDES the context value to children
    children: ReactNode - any valid React content (components, elements, etc.)
    
    In App.tsx we use it like:
    <AuthProvider>
        <AppRoutes />    ← These are the "children"
        <Chatbot />
    </AuthProvider>
*/

    // ============ STATE IN CONTEXT ============
    
    const [user, setUser] = useState<User | null>(null);
    // Currently logged in user, or null
    
    const [token, setToken] = useState<string | null>(localStorage.getItem('token'));
    // JWT token, initialized from localStorage (persists across page refresh)
    
    const [loading, setLoading] = useState<boolean>(true);
    // true while checking if user is logged in on app start


    // ============ INITIAL AUTH CHECK ============
    
    useEffect(() => {
        const loadUser = async () => {
            if (token) {
                try {
                    const response = await authApi.getCurrentUser();
                    setUser(response.data.user);
                } catch (error) {
                    localStorage.removeItem('token');
                    setToken(null);
                }
            }
            setLoading(false);
        };

        loadUser();
    }, [token]);
    /*
        Runs when component mounts and when token changes
        
        If token exists:
        1. Call /auth/me to verify token and get user data
        2. If successful: set user state
        3. If failed (token expired): clear token
        4. Set loading false when done
        
        This is how the app "remembers" you're logged in after page refresh
    */


    // ============ LOGIN FUNCTION ============
    
    const login = async (credentials: LoginCredentials) => {
        const response = await authApi.login(credentials);
        const { user: userData, token: userToken } = response.data;
        // Destructuring with rename: response.data.user → userData

        localStorage.setItem('token', userToken);
        setToken(userToken);
        setUser(userData);
    };
    // Called from LoginPage when user submits form


    // ============ REGISTER FUNCTION ============
    
    const register = async (data: RegisterData) => {
        const response = await authApi.register(data);
        const { user: userData, token: userToken } = response.data;

        if (userData.status === 'pending') {
            return;  // Don't auto-login organizers (they need approval)
        }

        localStorage.setItem('token', userToken);
        setToken(userToken);
        setUser(userData);
    };


    // ============ LOGOUT FUNCTION ============
    
    const logout = () => {
        authApi.logout().catch(() => { });  // Call API but ignore errors
        localStorage.removeItem('token');
        setToken(null);
        setUser(null);
    };


    // ============ PROVIDE VALUES TO CHILDREN ============
    
    return (
        <AuthContext.Provider
            value={{
                user,
                token,
                loading,
                login,
                register,
                logout,
                updateUser: (updatedUser: User) => setUser(updatedUser),
            }}
        >
            {children}
        </AuthContext.Provider>
    );
    /*
        AuthContext.Provider: Makes values available to all children
        value={{ }}: Object containing all the shared data and functions
        {children}: Renders whatever is passed as children
    */
};


// ============ STEP 3: CUSTOM HOOK TO USE CONTEXT ============

export const useAuth = (): AuthContextType => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};
/*
    Custom hook that:
    1. Gets the context value using useContext
    2. Throws error if used outside AuthProvider
    3. Returns the context value
    
    Usage in any component:
    const { user, login, logout } = useAuth();
*/
```


================================================================================
SECTION 8: REACT ROUTER - NAVIGATION
================================================================================

8.1 ROUTER SETUP (App.tsx)
---------------------------

```typescript
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';

const App: React.FC = () => {
    return (
        <BrowserRouter>
            <AuthProvider>
                <AppRoutes />
                <Chatbot />
            </AuthProvider>
        </BrowserRouter>
    );
};
/*
    BrowserRouter: Enables routing in the app
    - Uses HTML5 History API for clean URLs (/events, not /#/events)
    - Must wrap everything that uses routing
*/

const AppRoutes: React.FC = () => {
    return (
        <Routes>
            {/* PUBLIC ROUTES */}
            <Route path="/" element={<MainLayout><HomePage /></MainLayout>} />
            <Route path="/login" element={<MainLayout><LoginPage /></MainLayout>} />
            <Route path="/events" element={<MainLayout><EventsPage /></MainLayout>} />
            <Route path="/events/:id" element={<MainLayout><EventDetailsPage /></MainLayout>} />
            
            {/* PROTECTED ROUTE */}
            <Route
                path="/attendee/dashboard"
                element={
                    <MainLayout>
                        <ProtectedRoute allowedRoles={[UserRole.ATTENDEE]}>
                            <AttendeeDashboard />
                        </ProtectedRoute>
                    </MainLayout>
                }
            />
            
            {/* CATCH-ALL: Redirect unknown URLs */}
            <Route path="*" element={<Navigate to="/" replace />} />
        </Routes>
    );
};
/*
    Routes: Container for all Route definitions
    Route: Maps a URL path to a component
    
    path="/events/:id"
    - :id is a URL parameter
    - /events/abc123 → id = "abc123"
    - Component can access with useParams()
    
    path="*"
    - Matches any path not matched above
    - Navigate to="/" replaces URL with home
    - replace: Don't add to browser history
*/


8.2 HOOK: useNavigate
----------------------
// Programmatic navigation

const navigate = useNavigate();

// After successful login:
navigate('/');  // Go to home

// With options:
navigate('/login', { replace: true });  // Replace current history entry
navigate(-1);  // Go back (like browser back button)


8.3 HOOK: useParams
--------------------
// Get URL parameters

// Route: path="/events/:id"
// URL: /events/abc123

const { id } = useParams<{ id: string }>();
// id = "abc123"


8.4 COMPONENT: Link
--------------------
// Declarative navigation (clickable)

<Link to="/events">Browse Events</Link>
// Renders as <a href="/events">Browse Events</a>
// But doesn't reload page - React Router handles it

// With state (pass data to target):
<Link to="/event/123" state={{ from: 'homepage' }}>View Event</Link>


8.5 COMPONENT: Navigate
------------------------
// Redirect immediately

<Navigate to="/login" replace />
// Used for programmatic redirects in JSX
// replace: Don't add to history (can't "go back" to this page)
```


================================================================================
SECTION 9: COMPONENT PATTERNS YOU MUST KNOW
================================================================================

9.1 CONTROLLED INPUT
---------------------
Value is controlled by React state:

```typescript
const [email, setEmail] = useState('');

<input
    type="email"
    value={email}                    // State controls what's displayed
    onChange={(e) => setEmail(e.target.value)}  // Update state on change
/>
```
React is "single source of truth" for the input value.


9.2 CONDITIONAL RENDERING
--------------------------

```typescript
// Pattern 1: && (AND) operator
{error && <Alert>{error}</Alert>}
// If error is truthy, render Alert; otherwise render nothing

// Pattern 2: Ternary operator
{loading ? <Spinner /> : <Content />}
// If loading is true, render Spinner; otherwise render Content

// Pattern 3: if/else (use for complex logic)
const renderContent = () => {
    if (loading) return <Spinner />;
    if (error) return <ErrorView />;
    if (data.length === 0) return <EmptyState />;
    return <DataList data={data} />;
};
```


9.3 LIST RENDERING
-------------------

```typescript
const items = ['Apple', 'Banana', 'Cherry'];

// In JSX:
<ul>
    {items.map((item, index) => (
        <li key={index}>{item}</li>
    ))}
</ul>

// With objects:
const events = [{ id: '1', title: 'Event A' }, { id: '2', title: 'Event B' }];

{events.map((event) => (
    <EventCard key={event.id} event={event} />
))}
/*
    key: Required for React to track items efficiently
    - Use unique ID from data, not array index (when possible)
    - Helps React know what changed/added/removed
*/
```


9.4 PROP PASSING
-----------------

```typescript
// Parent component:
<EventCard 
    event={myEvent}           // Object prop
    onBook={handleBook}       // Function prop
    isHighlighted={true}      // Boolean prop
/>

// Child component:
interface EventCardProps {
    event: EventType;
    onBook: (eventId: string) => void;
    isHighlighted?: boolean;  // Optional (has ?)
}

const EventCard: React.FC<EventCardProps> = ({ event, onBook, isHighlighted = false }) => {
    // isHighlighted = false: Default value if not provided
    
    return (
        <div className={isHighlighted ? 'highlighted' : ''}>
            <h3>{event.title}</h3>
            <button onClick={() => onBook(event.id)}>Book</button>
        </div>
    );
};
```


9.5 CHILDREN PROP
------------------

```typescript
// Special prop for nested content

// Parent usage:
<MainLayout>
    <HomePage />
</MainLayout>

// MainLayout component:
interface MainLayoutProps {
    children: React.ReactNode;  // Can be any valid React content
}

const MainLayout: React.FC<MainLayoutProps> = ({ children }) => {
    return (
        <div>
            <Navbar />
            <main>{children}</main>  {/* HomePage renders here */}
            <Footer />
        </div>
    );
};
```


================================================================================
SECTION 10: INTERVIEW TOPICS CHECKLIST
================================================================================

Make sure you can explain these:

□ What is JSX? How is it different from HTML?
□ Difference between props and state
□ What is useState? Why can't you just modify variables directly?
□ What is useEffect? When does it run?
□ What is the dependency array in useEffect?
□ What is Context API? When would you use it?
□ What is a controlled component/input?
□ Why do we need keys in lists?
□ What is the Virtual DOM?
□ What is React.FC?
□ What is the difference between Link and anchor tag?
□ How does React Router work?
□ What are interceptors in axios?
□ How do you handle async operations in React?
□ What is the purpose of e.preventDefault()?
□ What is the spread operator (...) and how is it used in React?
□ What is destructuring?
□ What is a custom hook?
□ What is TypeScript and why use it with React?


================================================================================
SECTION 11: COMMON INTERVIEW QUESTIONS WITH ANSWERS
================================================================================

Q: What happens when you call setState?
A: React marks the component for re-render. It doesn't update immediately.
   React batches updates for performance. The new render uses the new state.

Q: Can you modify state directly?
A: No! state.value = newValue won't trigger re-render.
   Always use the setter function: setValue(newValue).

Q: What is the difference between useEffect with [] and without []?
A: [] = runs once on mount
   No array = runs after every render (rarely wanted)
   [dep1, dep2] = runs on mount and when deps change

Q: How do you prevent a form from refreshing the page?
A: e.preventDefault() in the onSubmit handler.
   Forms by default perform a GET request, causing page reload.

Q: What is lifting state up?
A: Moving state to a common parent when two components need the same data.
   Child components receive state via props.

Q: What is prop drilling?
A: Passing props through many levels of components.
   Context API solves this by providing global state.

Q: Why use TypeScript with React?
A: Catches type errors at compile time.
   Better IDE support (autocomplete, refactoring).
   Self-documenting code with interfaces.

Q: How do you handle API errors in React?
A: try/catch blocks with async/await.
   Set error state and display to user.
   Use error boundaries for component errors.

Q: What is the purpose of keys in lists?
A: React uses keys to identify which items changed/added/removed.
   Helps with efficient re-rendering and maintaining component state.


================================================================================
END OF INTERVIEW GUIDE
================================================================================
